{\rtf1\ansi\ansicpg1251\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red100\green56\blue32;\red255\green255\blue255;\red196\green26\blue22;
\red170\green13\blue145;\red0\green0\blue0;\red92\green38\blue153;\red28\green0\blue207;\red63\green110\blue116;
\red46\green13\blue110;\red38\green71\blue75;}
{\*\expandedcolortbl;;\csgenericrgb\c39100\c22000\c12500;\csgray\c100000;\csgenericrgb\c77000\c10200\c8600;
\csgenericrgb\c66500\c5200\c56900;\csgenericrgb\c0\c0\c0;\csgenericrgb\c35900\c14900\c60100;\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c24700\c43100\c45600;
\csgenericrgb\c18100\c5200\c43100;\csgenericrgb\c14900\c27800\c29400;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab543
\pard\tx543\pardeftab543\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \cb3 #include\cf4 <iostream>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <queue>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <map>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <set>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <cmath>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <algorithm>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <vector>
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 using\cf6  \cf5 namespace\cf6  \cf7 std\cf6 ;
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 int\cf6  n;
\f1\fs24 \cf0 \

\f0\fs22 \cf5 const\cf6  \cf5 int\cf6  INF = \cf8 1e9\cf6 ;
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 struct\cf6  node\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  mn, mx;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     node(\cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  mn = \cf8 0\cf6 , \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  mx = \cf8 0\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 this\cf6 ->\cf9 mn\cf6  = mn;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 this\cf6 ->\cf9 mx\cf6  = mx;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \};
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 void\cf6  recalc(\cf7 vector\cf6 <\cf9 node\cf6 > & tree, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  v)\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     tree[\cf10 v\cf6 ].\cf9 mn\cf6  = \cf10 min\cf6 (tree[\cf8 2\cf6  * \cf10 v\cf6 ].\cf9 mn\cf6 , tree[\cf8 2\cf6  * \cf10 v\cf6  + \cf8 1\cf6 ].\cf9 mn\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6     tree[\cf10 v\cf6 ].\cf9 mx\cf6  = \cf10 max\cf6 (tree[\cf8 2\cf6  * \cf10 v\cf6 ].\cf9 mx\cf6 , tree[\cf8 2\cf6  * \cf10 v\cf6  + \cf8 1\cf6 ].\cf9 mx\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 void\cf6  update_point(\cf7 vector\cf6 <\cf9 node\cf6 > & tree, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  i, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  new_val, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  v = \cf8 1\cf6 , \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  vl = \cf8 0\cf6 , \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  vr = \cf9 n\cf6 ) \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (vr - vl == \cf8 1\cf6 ) \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         tree[\cf10 v\cf6 ] = \{new_val, new_val\};
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 return\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  vm = (vl + vr) / \cf8 2\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (i < vl || i >= vr)\cf5 return\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (i < vm) \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf11 update_point\cf6 (tree, i, new_val, \cf8 2\cf6  * v, vl, vm);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}\cf5 else\cf6  \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf11 update_point\cf6 (tree, i, new_val, \cf8 2\cf6  * v + \cf8 1\cf6 , vm, vr);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf11 recalc\cf6 (tree, v);
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  get_min(\cf7 vector\cf6 <\cf9 node\cf6 > & tree, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  L, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  R, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  v = \cf8 1\cf6 , \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  vl = \cf8 0\cf6 , \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  vr = \cf9 n\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (vl >= R || vr <= L)\cf5 return\cf6  \cf9 INF\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (vr - vl <= \cf8 1\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  m = tree[\cf10 v\cf6 ].\cf9 mn\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         tree[\cf10 v\cf6 ].\cf9 mn\cf6  = \cf9 INF\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         tree[\cf10 v\cf6 ].\cf9 mx\cf6  = -\cf9 INF\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 return\cf6  m;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  vm = (vl + vr) / \cf8 2\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  res_m = \cf8 0\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (tree[\cf8 2\cf6  * \cf10 v\cf6 ].\cf9 mn\cf6  < tree[\cf8 2\cf6  * \cf10 v\cf6  + \cf8 1\cf6 ].\cf9 mn\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         res_m = \cf11 get_min\cf6 (tree, L, R, \cf8 2\cf6  * v, vl, vm);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}\cf5 else\cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         res_m = \cf11 get_min\cf6 (tree, L, R, \cf8 2\cf6  * v + \cf8 1\cf6 , vm, vr);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf11 recalc\cf6 (tree, v);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 return\cf6  res_m;
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  get_max(\cf7 vector\cf6 <\cf9 node\cf6 > & tree, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  L, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  R, \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  v = \cf8 1\cf6 , \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  vl = \cf8 0\cf6 , \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  vr = \cf9 n\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (vl >= R || vr <= L)\cf5 return\cf6  -\cf9 INF\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (vr - vl <= \cf8 1\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  m = tree[\cf10 v\cf6 ].\cf9 mx\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         tree[\cf10 v\cf6 ].\cf9 mx\cf6  = -\cf9 INF\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         tree[\cf10 v\cf6 ].\cf9 mn\cf6  = \cf9 INF\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 return\cf6  m;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  vm = (vl + vr) / \cf8 2\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  res_m = \cf8 0\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (tree[\cf8 2\cf6  * \cf10 v\cf6 ].\cf9 mx\cf6  > tree[\cf8 2\cf6  * \cf10 v\cf6  + \cf8 1\cf6 ].\cf9 mx\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         res_m = \cf11 get_max\cf6 (tree, L, R, \cf8 2\cf6  * v, vl, vm);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}\cf5 else\cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         res_m = \cf11 get_max\cf6 (tree, L, R, \cf8 2\cf6  * v + \cf8 1\cf6 , vm, vr);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf11 recalc\cf6 (tree, v);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 return\cf6  res_m;
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\
\

\f0\fs22 \cf5 int\cf6  main()\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 cin\cf6  >> \cf9 n\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf7 vector\cf6 <\cf9 node\cf6 > tree(\cf8 4\cf6  * \cf9 n\cf6 , \{\cf9 INF\cf6 , -\cf9 INF\cf6 \});
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 int\cf6  kol = \cf8 0\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 for\cf6  (\cf5 int\cf6  i = \cf8 0\cf6 ; i < \cf9 n\cf6 ; i++)\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf7 string\cf6  s;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf7 cin\cf6  >> s;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 if\cf6  (s[\cf8 0\cf6 ] == \cf8 'G'\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \cf5 if\cf6  (s[\cf8 4\cf6 ] == \cf8 'i'\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf7 cout\cf6  << \cf11 get_min\cf6 (tree, \cf8 0\cf6 , \cf9 n\cf6 ) << \cf10 endl\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \cf5 else\cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6                 \cf7 cout\cf6  << \cf11 get_max\cf6 (tree, \cf8 0\cf6 , \cf9 n\cf6 ) << \cf10 endl\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \}\cf5 else\cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \cf5 int\cf6  a = \cf10 stoi\cf6 (s.\cf10 substr\cf6 (\cf8 7\cf6 , s.\cf10 size\cf6 () - \cf8 8\cf6 ));
\f1\fs24 \cf0 \

\f0\fs22 \cf6             \cf11 update_point\cf6 (tree, kol, a);
\f1\fs24 \cf0 \

\f0\fs22 \cf6             kol++;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 return\cf6  \cf8 0\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
}