{\rtf1\ansi\ansicpg1251\cocoartf1561\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red100\green56\blue32;\red255\green255\blue255;\red196\green26\blue22;
\red170\green13\blue145;\red0\green0\blue0;\red28\green0\blue207;}
{\*\expandedcolortbl;;\csgenericrgb\c39100\c22000\c12500;\csgray\c100000;\csgenericrgb\c77000\c10200\c8600;
\csgenericrgb\c66500\c5200\c56900;\csgenericrgb\c0\c0\c0;\csgenericrgb\c11000\c0\c81000;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab543
\pard\tx543\pardeftab543\pardirnatural\partightenfactor0

\f0\fs22 \cf2 \cb3 #include\cf4 <iostream>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <queue>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <map>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <set>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <cmath>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <algorithm>
\f1\fs24 \cf0 \

\f0\fs22 \cf2 #include\cf4 <vector>
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 using\cf6  \cf5 namespace\cf6  std;
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 int\cf6  n;
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 void\cf6  build(vector<\cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6 > & a, vector<\cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6 > & tree, \cf5 int\cf6  v = \cf7 1\cf6 , \cf5 int\cf6  vl = \cf7 0\cf6 , \cf5 int\cf6  vr = n) \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (vr - vl == \cf7 1\cf6 ) \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         tree[v] = a[vl];
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 return\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 int\cf6  vm = (vl + vr) / \cf7 2\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     build(a, tree, \cf7 2\cf6  * v, vl, vm);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     build(a, tree, \cf7 2\cf6  * v + \cf7 1\cf6 , vm, vr);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     tree[v] = tree[\cf7 2\cf6  * v] + tree[\cf7 2\cf6  * v + \cf7 1\cf6 ];
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 void\cf6  update_point(vector<\cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6 > & tree, \cf5 int\cf6  i, \cf5 int\cf6  new_val, \cf5 int\cf6  v = \cf7 1\cf6 , \cf5 int\cf6  vl = \cf7 0\cf6 , \cf5 int\cf6  vr = n) \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (vr - vl == \cf7 1\cf6 ) \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         tree[v] = new_val;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 return\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 int\cf6  vm = (vl + vr) / \cf7 2\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (i < vm) \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         update_point(tree, i, new_val, \cf7 2\cf6  * v, vl, vm);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}\cf5 else\cf6  \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         update_point(tree, i, new_val, \cf7 2\cf6  * v + \cf7 1\cf6 , vm, vr);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     tree[v] = tree[\cf7 2\cf6  * v] + tree[\cf7 2\cf6  * v + \cf7 1\cf6 ];
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6  sum_on_seg(vector<\cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6 > & tree, \cf5 int\cf6  L, \cf5 int\cf6  R, \cf5 int\cf6  v = \cf7 1\cf6 , \cf5 int\cf6  vl = \cf7 0\cf6 , \cf5 int\cf6  vr = n) \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (L <= vl && vr <= R) \cf5 return\cf6  tree[v];
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 if\cf6  (vr <= L || R <= vl) \cf5 return\cf6  \cf7 0\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 int\cf6  vm = (vl + vr) / \cf7 2\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 return\cf6  sum_on_seg(tree, L, R, \cf7 2\cf6  * v, vl, vm) + sum_on_seg(tree, L, R, \cf7 2\cf6  * v + \cf7 1\cf6 , vm, vr);
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
\

\f0\fs22 \cf5 int\cf6  main()\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6     ios_base::sync_with_stdio(\cf7 0\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6     cin.tie(\cf7 0\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 int\cf6  x, y, m;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 char\cf6  c;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     cin >> n >> m;
\f1\fs24 \cf0 \

\f0\fs22 \cf6     vector<\cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6 > a(n, \cf7 0\cf6 );
\f1\fs24 \cf0 \

\f0\fs22 \cf6     vector<\cf5 long\cf6  \cf5 long\cf6  \cf5 int\cf6 > tree(\cf7 4\cf6  * n);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     build(a, tree);
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 for\cf6  (\cf5 int\cf6  i = \cf7 0\cf6 ; i < m; i++)\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6         cin >> c >> x >> y;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \cf5 if\cf6  (c == \cf7 'A'\cf6 )\{
\f1\fs24 \cf0 \

\f0\fs22 \cf6             update_point(tree, x - \cf7 1\cf6 , y);
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \}\cf5 else\cf6 \{
\f1\fs24 \cf0 \

\f0\fs22 \cf6             cout << sum_on_seg(tree, x - \cf7 1\cf6 , y) << endl;
\f1\fs24 \cf0 \

\f0\fs22 \cf6         \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \}
\f1\fs24 \cf0 \

\f0\fs22 \cf6     \cf5 return\cf6  \cf7 0\cf6 ;
\f1\fs24 \cf0 \

\f0\fs22 \cf6 \}
\f1\fs24 \cf0 \
}